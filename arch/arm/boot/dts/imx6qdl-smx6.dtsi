/*
 * The code contained herein is licensed under the GNU General Public
 * License. You may obtain a copy of the GNU General Public License
 * Version 2 or later at the following locations:
 *
 * http://www.opensource.org/licenses/gpl-license.html
 * http://www.gnu.org/copyleft/gpl.html
 */

#if !defined(SMX6_CPU_IMX6Q) && !defined(SMX6_CPU_IMX6DL)
#error Please define CPU type
#endif
#if defined(SMX6_CPU_IMX6Q) && defined(SMX6_CPU_IMX6DL)
#error Please define single CPU type
#endif

#if !defined(SMX6_PANEL_LCD) && !defined(SMX6_PANEL_LVDS)
#error Please define panel interface type
#endif
#if defined(SMX6_PANEL_LCD) && defined(SMX6_PANEL_LVDS)
#error Please define single panel interface type
#endif

#if !defined(SMX6_PANEL_24BIT) && !defined(SMX6_PANEL_18BIT)
#error Please define panel depth
#endif
#if defined(SMX6_PANEL_24BIT) && defined(SMX6_PANEL_18BIT)
#error Please define single panel depth
#endif

#include <dt-bindings/gpio/gpio.h>

#ifdef SMX6_CPU_IMX6Q
#define SMX6_COMPATIBLE "kontron,imx6q-smx6", "fsl,imx6q"
#include "imx6q.dtsi"
#endif
#ifdef SMX6_CPU_IMX6DL
#define SMX6_COMPATIBLE "kontron,imx6dl-smx6", "fsl,imx6dl"
#include "imx6dl.dtsi"
#endif

#ifndef SMX6_MODEL
#define SMX6_MODEL "Kontron SMARC-sAMX6i module"
#endif

#ifndef SMX6_PANEL_FB_DEPTH
#define SMX6_PANEL_FB_DEPTH	32
#endif

#ifndef SMX6_HDMI_FB_DEPTH
#define SMX6_HDMI_FB_DEPTH	24
#endif

#ifdef SMX6_PANEL_24BIT
#define SMX6_PANEL_PIXEL_DEPTH 24
#define SMX6_PANEL_PIXEL_FORMAT "RGB24"
#endif

#ifdef SMX6_PANEL_18BIT
#define SMX6_PANEL_PIXEL_DEPTH 18
#define SMX6_PANEL_PIXEL_FORMAT "RGB666"
#endif

#if defined(SMX6_HDCP) && defined(SMX6_PCB_0)
#error HDCP not supported on PCB_0
#endif

/* I2C mapping:
 * - differs between PCB versions
 * - IMX i2c3 is not available for SMX6_PTP case
 */
#define smarc_i2c_gp i2c1
#ifdef SMX6_PCB_0
#define smarc_i2c_pm i2c2
#ifndef SMX6_PTP
#define smarc_i2c_cam i2c3
#endif
#define smarc_i2c_hdmi smx6_i2c_gpio_1
#else
#ifndef SMX6_HDCP
#define smarc_i2c_hdmi i2c2
#endif
#ifndef SMX6_PTP
#define smarc_i2c_pm i2c3
#endif
#define smarc_i2c_cam smx6_i2c_gpio_1
#endif
#define smarc_i2c_lcd smx6_i2c_gpio_2
#define smx6_i2c_int smx6_i2c_gpio_0


/ {
	model = SMX6_MODEL;
	compatible = SMX6_COMPATIBLE;

	memory {
		reg = <0x10000000 0x40000000>;
	};

	aliases {
		spi0 = &ecspi4;
		spi1 = &ecspi2;
		i2c3 = &smx6_i2c_gpio_0;
		i2c4 = &smx6_i2c_gpio_1;
		i2c5 = &smx6_i2c_gpio_2;
	};

	smx6_panel_fb: fb@0 {
		status = "okay";
	};

	smx6_hdmi_fb: fb@1 {
		status = "okay";
	};

	display-subsystem {
                status = "okay";
	};

	gpu-subsystem {
                status = "okay";
	};

#ifdef SMX6_PANEL_LCD
	lcd_display: display@di0 {
		compatible = "fsl,imx-parallel-display";
		pinctrl-names = "default";
		pinctrl-0 = <&pinctrl_smx6_lcd>;
		interface-pix-fmt = "lvds666";
		status = "okay";

		port {
			display0_in: endpoint {
				remote-endpoint = <&ipu1_di0_disp0>;
			};
		};

		display-timings {
			native-mode = <&lvds_timing0>;
			lvds_timing0: PM070WL4 {
				clock-frequency = <22000000>;
				hactive = <800>;
				vactive = <480>;
				hback-porch = <86>;
				hfront-porch = <42>;
				vback-porch = <33>;
				vfront-porch = <10>;
				hsync-len = <128>;
				vsync-len = <2>;
				de-active = <1>;
				pixelclk-active = <0>;
			};

		};
	};
#endif
};

#ifdef SMX6_PANEL_LCD
&ipu1_di0_disp0 {
	remote-endpoint = <&display0_in>;
};
#endif

&smx6_hdmi_fb {
	default_bpp = <SMX6_HDMI_FB_DEPTH>;
	disp_dev = "hdmi";
	/* acual supported mode to be determined over edid, but need
	   initial setting for that to work */
	mode_str = "1920x1080M@60";
	interface_pix_fmt = "RGB24";
};

#ifdef SMX6_PANEL_LVDS
&ldb {
	status = "okay";

	lvds-channel@0 {
		fsl,data-mapping = "spwg";
		fsl,data-width = <SMX6_PANEL_PIXEL_DEPTH>;
		crtc = "ipu1-di0";
		primary;
		status = "okay";

		display-timings {
			native-mode = <&smx6_panel_timings>;
			smx6_panel_timings: panel {
			};
		};
	};
};
#endif

/ {
#define smarc_pwm_backlight smx6_pwm_backlight
	smx6_pwm_backlight: backlight {
		compatible = "pwm-backlight";
		pinctrl-names = "default";
		pinctrl-0 = <&pinctrl_smx6_backlight>;
		pwms = <&pwm4 0 5000000>;
		brightness-levels = <
			0  1  2  3  4  5  6  7  8  9
			10 11 12 13 14 15 16 17 18 19
			20 21 22 23 24 25 26 27 28 29
			30 31 32 33 34 35 36 37 38 39
			40 41 42 43 44 45 46 47 48 49
			50 51 52 53 54 55 56 57 58 59
			60 61 62 63 64 65 66 67 68 69
			70 71 72 73 74 75 76 77 78 79
			80 81 82 83 84 85 86 87 88 89
			90 91 92 93 94 95 96 97 98 99
			100
		>;
		default-brightness-level = <80>;
		enable-gpios = <&gpio1 16 GPIO_ACTIVE_HIGH>;
		fb = <&smx6_panel_fb>;
	};

	lcdpower {
		compatible = "gpio-backlight";
		pinctrl-names = "default";
		pinctrl-0 = <&pinctrl_smx6_lcdpower>;
		gpios = <&gpio1 17 GPIO_ACTIVE_HIGH>;
		default-on;
		fb = <&smx6_panel_fb>;
	};

	smx6_i2c_gpio_0: i2c-gpio-0 {
		compatible = "i2c-gpio";
		pinctrl-names = "default";
		pinctrl-0 = <&pinctrl_smx6_i2c_gpio_0>;
		gpios =
			<&gpio1 28 0>, /* sda */
			<&gpio1 30 0>; /* scl */
		#address-cells = <1>;
		#size-cells = <0>;
		i2c-gpio,delay-us = <2>;
	};

	smx6_i2c_gpio_1: i2c-gpio-1 {
		compatible = "i2c-gpio";
		pinctrl-names = "default";
		pinctrl-0 = <&pinctrl_smx6_i2c_gpio_1>;
		gpios =
			<&gpio4 10 0>, /* sda */
			<&gpio1 6 0>;  /* scl */
		#address-cells = <1>;
		#size-cells = <0>;
		i2c-gpio,delay-us = <2>;
	};

	smx6_i2c_gpio_2: i2c-gpio-2 {
		compatible = "i2c-gpio";
		pinctrl-names = "default";
		pinctrl-0 = <&pinctrl_smx6_i2c_gpio_2>;
		gpios =
			<&gpio1 21 0>, /* sda */
			<&gpio1 19 0>; /* scl */
		#address-cells = <1>;
		#size-cells = <0>;
		i2c-gpio,delay-us = <2>;
	};

	regulators {
		compatible = "simple-bus";
		#address-cells = <1>;
		#size-cells = <0>;

		reg_3v3_s5: regulator@0 {
			compatible = "regulator-fixed";
			reg = <0>;
			regulator-name = "V_3V3_S5";
			regulator-min-microvolt = <3300000>;
			regulator-max-microvolt = <3300000>;
			regulator-boot-on;
			regulator-always-on;
		};

		reg_1v8_s5: regulator@1 {
			compatible = "regulator-fixed";
			reg = <1>;
			regulator-name = "V_1V8_S5";
			regulator-min-microvolt = <1800000>;
			regulator-max-microvolt = <1800000>;
			regulator-boot-on;
			regulator-always-on;
		};

		reg_3v3_s0: regulator@2 {
			compatible = "regulator-fixed";
			reg = <2>;
			regulator-name = "V_3V3_S0";
			regulator-min-microvolt = <3300000>;
			regulator-max-microvolt = <3300000>;
			regulator-boot-on;
			regulator-always-on;
		};

		reg_1v0_s0: regulator@3 {
			compatible = "regulator-fixed";
			reg = <3>;
			regulator-name = "V_1V0_S0";
			regulator-min-microvolt = <1000000>;
			regulator-max-microvolt = <1000000>;
			regulator-boot-on;
			regulator-always-on;
		};
	};

	gpio-keys {
		compatible = "gpio-keys";
		pinctrl-names = "default";
		pinctrl-0 = <&pinctrl_smx6_keys>;
		power {
			label = "Power";
			gpios = <&gpio6 16 1>;
			linux,code = <116>; /* KEY_POWER */
			gpio-key,wakeup;
			debounce-interval = <1>;
		};

		sleep {
			label = "Sleep";
			gpios = <&gpio6 17 1>;
			linux,code = <142>; /* KEY_SLEEP */
			gpio-key,wakeup;
			debounce-interval = <1>;
		};

		lid {
			label = "Lid";
			gpios = <&gpio5 0 1>;
			linux,input-type = <5>; /* EV_SW */
			linux,code = <0>; /* SW_LID */
			gpio-key,wakeup;
			debounce-interval = <1>;
		};
	};

	v4l2_out {
		compatible = "fsl,mxc_v4l2_output";
		status = "okay";
	};
};

#define smarc_ser0 uart1
&uart1 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_smx6_uart1>;
	fsl,uart-has-rtscts;
};

#define smarc_ser1 uart2
&uart2 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_smx6_uart2>;
};

#define smarc_ser2 uart4
&uart4 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_smx6_uart4>;
	fsl,uart-has-rtscts;
};

#define smarc_ser3 uart5
&uart5 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_smx6_uart5>;
};

#define smarc_gbe fec
&fec {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_smx6_enet_fec>;
	phy-mode = "rgmii";
	phy-supply = <&reg_3v3_s0>;
	fsl,magic-packet;
};

#define smarc_spi0 ecspi4
&ecspi4 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_smx6_ecspi4>;
	fsl,spi-num-chipselects = <3>;
	cs-gpios = <&gpio3 24 0>, <&gpio3 29 0>, <&gpio3 25 0>;
	status = "okay";
};

#define smarc_spi1 ecspi2
&ecspi2 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_smx6_ecspi2>;
	fsl,spi-num-chipselects = <2>;
	cs-gpios = <&gpio2 26 0>, <&gpio2 27 0>;
	status = "okay";
};

#define smarc_usb0 usbotg
#define USB0_EN_OC_GPIO_PORT gpio5
#define USB0_EN_OC_GPIO_NUM 18
&usbotg {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_smx6_usbotg>;
	/* no 'imx6-usb-charger-detection' since USB_OTG_CHD_B pin is not wired */
};

#define smarc_usb1 usbh1
&usbh1 {
	vbus-supply = <&reg_3v3_s0>;
};

#define smarc_sdmmc usdhc2
&usdhc2 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_smx6_usdhc2>;
	bus-width = <8>;
	cd-gpios = <&gpio1 4 GPIO_ACTIVE_LOW>;	/* per schematics, always constant? */
};

#define smarc_sdio usdhc3
&usdhc3 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_smx6_usdhc3>;
	bus-width = <4>;
	cd-gpios = <&gpio6 14 GPIO_ACTIVE_LOW>;
	wp-gpios = <&gpio1 26 GPIO_ACTIVE_HIGH>;
};
#define SMARC_SDIO_PWR_EN_GPIO <&gpio1 29 0>

#ifndef SMX6_HIDE_EMMC
&usdhc4 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_smx6_usdhc4>;
	bus-width = <8>;
	no-1-8-v;
	non-removable;
	status = "okay";
};
#endif

&pwm4 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_smx6_pwm4>;
	status = "okay";
};

&i2c1 {
	clock-frequency = <100000>;
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_smx6_i2c1>;
	status = "okay";
};

#ifndef SMX6_HDCP
&i2c2 {
	clock-frequency = <100000>;
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_smx6_i2c2>;
	status = "okay";
};
#endif

#ifndef SMX6_PTP
&i2c3 {
	clock-frequency = <100000>;
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_smx6_i2c3>;
	status = "okay";
};
#endif

&pcie {
	fsl,max-link-speed = <1>;
	wake-up-gpio = <&gpio6 18 0>;

	/* Even for board without pcie switch, adding more reset GPIOs
	   won't harm */
	reset-gpio = <&gpio2 0 GPIO_ACTIVE_LOW>,
		     <&gpio3 13 GPIO_ACTIVE_LOW>,
		     <&gpio3 14 GPIO_ACTIVE_LOW>,
		     <&gpio3 15 GPIO_ACTIVE_LOW>;

	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_smx6_pcie>;
	status = "okay";
};

#ifdef SMX6_CPU_IMX6Q
#define smarc_sata sata
#endif

#define smarc_can0 can1
&can1 {
        pinctrl-names = "default";
        pinctrl-0 = <&pinctrl_smx6_flexcan1>;
};

#define smarc_can1 can2
&can2 {
        pinctrl-names = "default";
        pinctrl-0 = <&pinctrl_smx6_flexcan2>;
};

&smx6_i2c_int {
	pfuze100@08 {
		compatible = "fsl,pfuze100";
		reg = <0x08>;

		/* Looks unused by pfuze100 driver */
		interrupt-parent = <&gpio7>;
		interrupts = <13 8>;	/* 8 = level, active low */

		regulators {
			vsnvs {
				regulator-min-microvolt = <1000000>;
				regulator-max-microvolt = <3000000>;
				regulator-boot-on;
				regulator-always-on;
			};

			reg_v_core_s0: sw1ab {
				regulator-name = "V_CORE_S0";
				regulator-min-microvolt = <300000>;
				regulator-max-microvolt = <1875000>;
				regulator-boot-on;
				regulator-always-on;
			};

			reg_vddsoc_s0: sw1c {
				regulator-name = "V_VDDSOC_S0";
				regulator-min-microvolt = <300000>;
				regulator-max-microvolt = <1875000>;
				regulator-boot-on;
				regulator-always-on;
			};

			reg_3v15_s0: sw2 {
				regulator-name = "V_3V15_S0";
				regulator-min-microvolt = <800000>;
				regulator-max-microvolt = <3300000>;
				regulator-boot-on;
				regulator-always-on;
			};

			/* sw3a/b is used in dual mode, but driver does not
			 * support it?  anyway, no need to control DDR
			 * power - so just leaving dummy entries for sw3a
			 * and sw3b for now */

			sw3a {
				regulator-min-microvolt = <400000>;
				regulator-max-microvolt = <1975000>;
				regulator-boot-on;
				regulator-always-on;
			};

			sw3b {
				regulator-min-microvolt = <400000>;
				regulator-max-microvolt = <1975000>;
				regulator-boot-on;
				regulator-always-on;
			};

			reg_1v8_s0: sw4 {
				regulator-name = "V_1V8_S0";
				regulator-min-microvolt = <800000>;
				regulator-max-microvolt = <3300000>;
				regulator-boot-on;
				regulator-always-on;
			};

			reg_5v0_s0: swbst {
				regulator-name = "V_5V0_S0";
				regulator-min-microvolt = <5000000>;
				regulator-max-microvolt = <5150000>;
				regulator-always-on;
			};

			vrefddr {
				regulator-boot-on;
				regulator-always-on;
			};

			/* Per schematics, of all VGEN's, only VGEN5 has some
			   usage ... but even that - over DNI resistor */

			vgen1 {
				regulator-min-microvolt = <800000>;
				regulator-max-microvolt = <1550000>;
			};

			vgen2 {
				regulator-min-microvolt = <800000>;
				regulator-max-microvolt = <1550000>;
			};

			vgen3 {
				regulator-min-microvolt = <1800000>;
				regulator-max-microvolt = <3300000>;
			};

			vgen4 {
				regulator-min-microvolt = <1800000>;
				regulator-max-microvolt = <3300000>;
			};

			reg_2v5_s0: vgen5 {
				regulator-name = "V_2V5_S0";
				regulator-min-microvolt = <1800000>;
				regulator-max-microvolt = <3300000>;
			};

			vgen6 {
				regulator-min-microvolt = <1800000>;
				regulator-max-microvolt = <3300000>;
			};
		};
	};
};

#ifndef SMX6_HIDE_SPI_FLASH
&smarc_spi0 {
	spi-nor@0 {
		#address-cells = <1>;
		#size-cells = <1>;
		compatible = "winbond,w25q16dw", "jedec,spi-nor";
		spi-max-frequency = <20000000>;
		reg = <0>;

		partition@0 {
			label = "bootloader";
			reg = <0x000000 0x0c0000>;
			read-only;
		};
		partition@c0000 {
			label = "environment";
			reg = <0x0c0000 0x010000>;
		};
		partition@d0000 {
			label = "user";
			/* 0 instead of size means "use the rest" - should
			   work both with w25q16dw and w25q64dw */
			reg = <0x0d0000 0>;
		};
	};
};
#endif

#ifdef SMX6_CPU_IMX6Q
#define smarc_sata sata
#endif

&hdmi {

	ddc-i2c-bus = <&i2c2>;

#ifdef SMX6_CPU_IMX6Q
	ipu_id = <1>;
	disp_id = <0>;
#endif
#ifdef SMX6_CPU_IMX6DL
	ipu_id = <0>;
	disp_id = <1>;
#endif
	status = "okay";
};

#ifdef smarc_i2c_pm
&smarc_i2c_pm {
	at24@50 {
		compatible = "at24,24c32";
		pagesize = <8>;
		reg = <0x50>;
	};
};
#endif

/* comment out WGOR_B pin configuration for now - it causes board reboots

   Supposedly reboots are caused by WDOG_B signal activation by Power Down
   Counter that is located in watchdog module, is on at poweron time, and
   fires if not stopped in 16 seconds from poweron */

/*&wdog1 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_smx6_wdog1>;
};*/


/* audio path:
 *   audio sources ssi1, ssi2, ssi3 corresponds to audmux ports 1, 2, 7
 *   audmux ports 3, 4, 5 correspond to SMARC interfaces I2S1, I2S2, I2S3
 * usage:
 *   - define SMX6_SSIn_AUDIO to enable SSIn as audio processor,
 *   - define SMX6_SSIn_AUDIO_OUTPUT=M to route that audio to SMARC i2sM,
 *     that will result into smarc_i2sM_audio label defined pointing to
 *     node with audio processor and mux defined
 *   - define codec and complete that definition of audio node in carrier dtsi
 */

#define SMARC_AUDIO_MCLK  <&clks IMX6QDL_CLK_CKO2>

#if defined(SMX6_SSI1_AUDIO) || defined(SMX6_SSI2_AUDIO) || defined(SMX6_SSI3_AUDIO)
&audmux {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_smx6_audmux>;
	status = "okay";
};
#endif

#ifdef SMX6_SSI1_AUDIO

#if SMX6_SSI1_AUDIO_OUTPUT == 0
#define smarc_i2s0_audio smx6_ssi1_audio
#define SMX6_SSI1_MUX_EXT_PORT 3
#elif SMX6_SSI1_AUDIO_OUTPUT == 1
#define smarc_i2s1_audio smx6_ssi1_audio
#define SMX6_SSI1_MUX_EXT_PORT 4
#elif SMX6_SSI1_AUDIO_OUTPUT == 2
#define smarc_i2s2_audio smx6_ssi1_audio
#define SMX6_SSI1_MUX_EXT_PORT 5
#else
#error Invalid SMX6_SSI1_AUDIO_OUTPUT setting
#endif

&ssi1 {
	status = "okay";
};

/ {
	smx6_ssi1_audio: ssi1_audio {
		ssi-controller = <&ssi1>;
		mux-int-port = <1>;
		mux-ext-port = <SMX6_SSI1_MUX_EXT_PORT>;
	};
};

#endif

#ifdef SMX6_SSI2_AUDIO

#if SMX6_SSI2_AUDIO_OUTPUT == 0
#define smarc_i2s0_audio smx6_ssi2_audio
#define SMX6_SSI2_MUX_EXT_PORT 3
#elif SMX6_SSI2_AUDIO_OUTPUT == 1
#define smarc_i2s1_audio smx6_ssi2_audio
#define SMX6_SSI2_MUX_EXT_PORT 4
#elif SMX6_SSI2_AUDIO_OUTPUT == 2
#define smarc_i2s2_audio smx6_ssi2_audio
#define SMX6_SSI2_MUX_EXT_PORT 5
#else
#error Invalid SMX6_SSI2_AUDIO_OUTPUT setting
#endif

&ssi2 {
	status = "okay";
};

/ {
	smx6_ssi2_audio: ssi2_audio {
		ssi-controller = <&ssi2>;
		mux-int-port = <2>;
		mux-ext-port = <SMX6_SSI2_MUX_EXT_PORT>;
	};
};

#endif

#ifdef SMX6_SSI3_AUDIO

#if SMX6_SSI3_AUDIO_OUTPUT == 0
#define smarc_i2s0_audio smx6_ssi3_audio
#define SMX6_SSI3_MUX_EXT_PORT 3
#elif SMX6_SSI3_AUDIO_OUTPUT == 1
#define smarc_i2s1_audio smx6_ssi3_audio
#define SMX6_SSI3_MUX_EXT_PORT 4
#elif SMX6_SSI3_AUDIO_OUTPUT == 2
#define smarc_i2s2_audio smx6_ssi3_audio
#define SMX6_SSI3_MUX_EXT_PORT 5
#else
#error Invalid SMX6_SSI3_AUDIO_OUTPUT setting
#endif

&ssi3 {
	status = "okay";
};

/ {
	smx6_ssi3_audio: ssi3_audio {
		ssi-controller = <&ssi3>;
		mux-int-port = <7>;
		mux-ext-port = <SMX6_SSI3_MUX_EXT_PORT>;
	};
};

#endif


/* serial camera connection:
 *   MIPI CSI-2 supports multiplexing of up to 4 virtual channels, however
 *   current fsl drivers support only one, with id pre-configured in mipi-csi
 *   device tree node.
 *   On imx6q, each of 4 virtual channels is routed to particular IPU CSI
 *     (vc0 => ipu1-csi0, vc1 => ipu1-csi1, vc2-ipu2-csi0, vc3 => ipu1-csi1)
 *   On imx6dl, each of 4 virtual channels can be forwarded to either ipu-csi0
 *     or ipu-csi1. For smx6, useful configuration is to route used channel to
 *     ipu-csi0, since both ipu csi's are equivalent, and ipu-csi1 could be
 *     used for parallel camera that is hard-wired to it's input pins.
 * usage:
 *   - define SMX6_SERIAL_CAMERA to enable serial camera support
 *   - define SMX6_SERIAL_CAMERA_VC to select virtual channel used
 *     (could be 0, 1, 2 or 3)
 *   - define SMX6_SERIAL_CAMERA_LANES to set number if MIPI CSI-2 lanes used
 *     (could be 1 or 2 for smx6)
 *   - define camera node
 */

/* Phyically CLKO1 is routed to CAM_MCK... but current clk-imx6q code feeds
 * CLKO1 signal from from CLK_CKO2 (via bit 8 of CCM_CCOSR register, hidden
 * behind clk object named "cko") */
#define SMARC_SERIAL_CAMERA_MCLK	<&clks IMX6QDL_CLK_CKO2>
#define SMARC_SERIAL_CAMERA_POWER_GPIO	<&gpio3 0 GPIO_ACTIVE_HIGH>
#define SMARC_SERIAL_CAMERA_RESET_GPIO	<&gpio3 2 GPIO_ACTIVE_LOW>

#ifdef SMX6_SERIAL_CAMERA

#ifndef SMX6_SERIAL_CAMERA_ENDPOINT
#error Please define SMX6_SERIAL_CAMERA_ENDPOINT
#endif

#ifndef SMX6_SERIAL_CAMERA_CLOCK_LANES
#error Please define SMX6_SERIAL_CAMERA_CLOCK_LANES
#endif

#ifndef SMX6_SERIAL_CAMERA_DATA_LANES
#error Please define SMX6_SERIAL_CAMERA_DATA_LANES
#endif

&mipi_csi {
	status = "okay";

	port@0 {
		reg = <0>;

		mipi_csi2_in: endpoint {
			remote-endpoint = <&SMX6_SERIAL_CAMERA_ENDPOINT>;
			clock-lanes = <SMX6_SERIAL_CAMERA_CLOCK_LANES>;
			data-lanes = <SMX6_SERIAL_CAMERA_DATA_LANES>;
		};
	};
};
#endif

&iomuxc {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_smx6_hog>;

	hog {
		pinctrl_smx6_hog: hoggrp-smx6 {
			fsl,pins = <

				/* SMARC GPIO lines - enable SION bit */
				MX6QDL_PAD_EIM_DA0__GPIO3_IO00 0x4000b0b1
				MX6QDL_PAD_EIM_DA1__GPIO3_IO01 0x4000b0b1
				MX6QDL_PAD_EIM_DA2__GPIO3_IO02 0x4000b0b1
				MX6QDL_PAD_EIM_DA3__GPIO3_IO03 0x4000b0b1
				MX6QDL_PAD_EIM_DA4__GPIO3_IO04 0x4000b0b1
				MX6QDL_PAD_EIM_DA5__GPIO3_IO05 0x4000b0b1
				MX6QDL_PAD_EIM_DA6__GPIO3_IO06 0x4000b0b1
				MX6QDL_PAD_EIM_DA7__GPIO3_IO07 0x4000b0b1
				MX6QDL_PAD_EIM_DA8__GPIO3_IO08 0x4000b0b1
				MX6QDL_PAD_EIM_DA9__GPIO3_IO09 0x4000b0b1
				MX6QDL_PAD_EIM_DA10__GPIO3_IO10 0x4000b0b1
				MX6QDL_PAD_EIM_DA11__GPIO3_IO11 0x4000b0b1

#if defined(SMX6_SSI1_AUDIO) || defined(SMX6_SSI2_AUDIO) || defined(SMX6_SSI3_AUDIO)
				/* AUDIO_MCK */
				MX6QDL_PAD_NANDF_CS2__CCM_CLKO2 0x80000000
#endif

#ifdef SMX6_SERIAL_CAMERA
				/* CAM_MCK */
				MX6QDL_PAD_CSI0_MCLK__CCM_CLKO1 0x80000000
#endif
			>;
		};
	};

	uart1 {
		pinctrl_smx6_uart1: uart1grp-smx6 {
			fsl,pins = <
				MX6QDL_PAD_CSI0_DAT11__UART1_RX_DATA 0x1b0b1
				MX6QDL_PAD_CSI0_DAT10__UART1_TX_DATA 0x1b0b1
				MX6QDL_PAD_EIM_D20__UART1_RTS_B 0x1b0b1
				MX6QDL_PAD_EIM_D19__UART1_CTS_B 0x1b0b1
			>;
		};
	};

	uart2 {
		pinctrl_smx6_uart2: uart2grp-smx6 {
			fsl,pins = <
				MX6QDL_PAD_EIM_D27__UART2_RX_DATA 0x1b0b1
				MX6QDL_PAD_EIM_D26__UART2_TX_DATA 0x1b0b1
			>;
		};
	};

	uart4 {
		pinctrl_smx6_uart4: uart4grp-smx6 {
			fsl,pins = <
				MX6QDL_PAD_CSI0_DAT13__UART4_RX_DATA 0x1b0b1
				MX6QDL_PAD_CSI0_DAT12__UART4_TX_DATA 0x1b0b1
				MX6QDL_PAD_CSI0_DAT16__UART4_RTS_B 0x1b0b1
				MX6QDL_PAD_CSI0_DAT17__UART4_CTS_B 0x1b0b1
			>;
		};
	};
	
	uart5 {
		pinctrl_smx6_uart5: uart5grp-smx6 {
			fsl,pins = <
				MX6QDL_PAD_CSI0_DAT15__UART5_RX_DATA 0x1b0b1
				MX6QDL_PAD_CSI0_DAT14__UART5_TX_DATA 0x1b0b1
			>;
		};
	};

	fec {
		pinctrl_smx6_enet_fec: fecgrp-smx6 {
			fsl,pins = <
				MX6QDL_PAD_ENET_MDIO__ENET_MDIO       0x1b0b0
				MX6QDL_PAD_ENET_MDC__ENET_MDC         0x1b0b0
				MX6QDL_PAD_RGMII_TXC__RGMII_TXC       0x1b0b0
				MX6QDL_PAD_RGMII_TD0__RGMII_TD0       0x1b0b0
				MX6QDL_PAD_RGMII_TD1__RGMII_TD1       0x1b0b0
				MX6QDL_PAD_RGMII_TD2__RGMII_TD2       0x1b0b0
				MX6QDL_PAD_RGMII_TD3__RGMII_TD3       0x1b0b0
				MX6QDL_PAD_RGMII_TX_CTL__RGMII_TX_CTL 0x1b0b0
				MX6QDL_PAD_ENET_REF_CLK__ENET_TX_CLK  0x1b0b0
				MX6QDL_PAD_RGMII_RXC__RGMII_RXC       0x1b0b0
				MX6QDL_PAD_RGMII_RD0__RGMII_RD0       0x1b0b0
				MX6QDL_PAD_RGMII_RD1__RGMII_RD1       0x1b0b0
				MX6QDL_PAD_RGMII_RD2__RGMII_RD2       0x1b0b0
				MX6QDL_PAD_RGMII_RD3__RGMII_RD3       0x1b0b0
				MX6QDL_PAD_RGMII_RX_CTL__RGMII_RX_CTL 0x1b0b0
#ifdef SMX6_PTP
				MX6QDL_PAD_GPIO_16__ENET_REF_CLK      0x4001b0a8
#endif
			>;
		};
	};

	ecspi2 {
		pinctrl_smx6_ecspi2: ecspi2grp-smx6 {
			fsl,pins = <
				MX6QDL_PAD_EIM_CS0__ECSPI2_SCLK 0x80000000
				MX6QDL_PAD_EIM_CS1__ECSPI2_MOSI 0x80000000
				MX6QDL_PAD_EIM_OE__ECSPI2_MISO 0x80000000

				MX6QDL_PAD_EIM_RW__GPIO2_IO26 0x80000000
				MX6QDL_PAD_EIM_LBA__GPIO2_IO27 0x80000000
			>;
		};
	};

	ecspi4 {
		pinctrl_smx6_ecspi4: ecspi4grp-smx6 {
			fsl,pins = <
				MX6QDL_PAD_EIM_D21__ECSPI4_SCLK 0x80000000
				MX6QDL_PAD_EIM_D28__ECSPI4_MOSI 0x80000000
				MX6QDL_PAD_EIM_D22__ECSPI4_MISO 0x80000000

				/* In hardware, ECSPI4's SS0,SS1,SS3 are wired.
				   But spi-imx driver support only continuous
				   numbering, and only can use GPIOs (and not
				   ECSPI's hardware SS) for CS. So linux view
				   of CS numbers differs from hw view, and
				   pins are configured as GPIOs */

				/* physical - CS2, in linux - CS0, either internal flash or SMARC CS0 */
				MX6QDL_PAD_EIM_D24__GPIO3_IO24 0x80000000
				/* physical - CS0, in linux - CS1, either SMARC CS0 or not-connected */
				MX6QDL_PAD_EIM_D29__GPIO3_IO29 0x80000000
				/* physical - CS3, in linux - CS2, SMARC CS1 */
				MX6QDL_PAD_EIM_D25__GPIO3_IO25 0x80000000
			>;
		};
	};

	usbotg {
		pinctrl_smx6_usbotg: usbothgrp-smx6 {
			fsl,pins = <
				MX6QDL_PAD_GPIO_1__USB_OTG_ID 0x1f8b0
				MX6QDL_PAD_CSI0_PIXCLK__GPIO5_IO18 0x80000000	/* USB power */
				/* Comment out OC gpio for now, since these are not used by driver */
				// MX6QDL_PAD_CSI0_DATA_EN__GPIO5_IO20 0x80000000	/* USB OC */
			>;
		};
	};

	usdhc2 {
		pinctrl_smx6_usdhc2: usdhc2grp-smx6 {
			fsl,pins = <
				MX6QDL_PAD_SD2_CLK__SD2_CLK 0x17059
				MX6QDL_PAD_SD2_CMD__SD2_CMD 0x17059
				MX6QDL_PAD_SD2_DAT0__SD2_DATA0 0x17059
				MX6QDL_PAD_SD2_DAT1__SD2_DATA1 0x17059
				MX6QDL_PAD_SD2_DAT2__SD2_DATA2 0x17059
				MX6QDL_PAD_SD2_DAT3__SD2_DATA3 0x17059
				MX6QDL_PAD_NANDF_D4__SD2_DATA4 0x17059
				MX6QDL_PAD_NANDF_D5__SD2_DATA5 0x17059
				MX6QDL_PAD_NANDF_D6__SD2_DATA6 0x17059
				MX6QDL_PAD_NANDF_D7__SD2_DATA7 0x17059
				MX6QDL_PAD_GPIO_4__GPIO1_IO04 0x80000000 /* CD */
			>;
		};
	};

	usdhc3 {
		pinctrl_smx6_usdhc3: usdhc3grp-smx6 {
			fsl,pins = <
				MX6QDL_PAD_SD3_CLK__SD3_CLK 0x17059
				MX6QDL_PAD_SD3_CMD__SD3_CMD 0x17059
				MX6QDL_PAD_SD3_DAT0__SD3_DATA0 0x17059
				MX6QDL_PAD_SD3_DAT1__SD3_DATA1 0x17059
				MX6QDL_PAD_SD3_DAT2__SD3_DATA2 0x17059
				MX6QDL_PAD_SD3_DAT3__SD3_DATA3 0x17059
				MX6QDL_PAD_NANDF_CS1__GPIO6_IO14 0x80000000 /* CD */
				MX6QDL_PAD_ENET_RXD1__GPIO1_IO26 0x80000000 /* WP */
				/* FIXME: should this be moved to regulator's
					  group? */
				MX6QDL_PAD_ENET_TXD1__GPIO1_IO29 0x80000000 /* PWR_EN */
			>;
		};
	};

	usdhc4 {
		pinctrl_smx6_usdhc4: usdhc4grp-smx6 {
			fsl,pins = <
				MX6QDL_PAD_SD4_CLK__SD4_CLK 0x17059
				MX6QDL_PAD_SD4_CMD__SD4_CMD 0x17059
				MX6QDL_PAD_SD4_DAT0__SD4_DATA0 0x17059
				MX6QDL_PAD_SD4_DAT1__SD4_DATA1 0x17059
				MX6QDL_PAD_SD4_DAT2__SD4_DATA2 0x17059
				MX6QDL_PAD_SD4_DAT3__SD4_DATA3 0x17059
				MX6QDL_PAD_SD4_DAT4__SD4_DATA4 0x17059
				MX6QDL_PAD_SD4_DAT5__SD4_DATA5 0x17059
				MX6QDL_PAD_SD4_DAT6__SD4_DATA6 0x17059
				MX6QDL_PAD_SD4_DAT7__SD4_DATA7 0x17059
			>;
		};
	};

	lcd {
		pinctrl_smx6_lcd: lcdgrp-smx6 {
			fsl,pins = <
				MX6QDL_PAD_DISP0_DAT0__IPU1_DISP0_DATA00 0x100f1
				MX6QDL_PAD_DISP0_DAT1__IPU1_DISP0_DATA01 0x100f1
				MX6QDL_PAD_DISP0_DAT2__IPU1_DISP0_DATA02 0x100f1
				MX6QDL_PAD_DISP0_DAT3__IPU1_DISP0_DATA03 0x100f1
				MX6QDL_PAD_DISP0_DAT4__IPU1_DISP0_DATA04 0x100f1
				MX6QDL_PAD_DISP0_DAT5__IPU1_DISP0_DATA05 0x100f1
				MX6QDL_PAD_DISP0_DAT6__IPU1_DISP0_DATA06 0x100f1
				MX6QDL_PAD_DISP0_DAT7__IPU1_DISP0_DATA07 0x100f1
				MX6QDL_PAD_DISP0_DAT8__IPU1_DISP0_DATA08 0x100f1
				MX6QDL_PAD_DISP0_DAT9__IPU1_DISP0_DATA09 0x100f1
				MX6QDL_PAD_DISP0_DAT10__IPU1_DISP0_DATA10 0x100f1
				MX6QDL_PAD_DISP0_DAT11__IPU1_DISP0_DATA11 0x100f1
				MX6QDL_PAD_DISP0_DAT12__IPU1_DISP0_DATA12 0x100f1
				MX6QDL_PAD_DISP0_DAT13__IPU1_DISP0_DATA13 0x100f1
				MX6QDL_PAD_DISP0_DAT14__IPU1_DISP0_DATA14 0x100f1
				MX6QDL_PAD_DISP0_DAT15__IPU1_DISP0_DATA15 0x100f1
				MX6QDL_PAD_DISP0_DAT16__IPU1_DISP0_DATA16 0x100f1
				MX6QDL_PAD_DISP0_DAT17__IPU1_DISP0_DATA17 0x100f1
				MX6QDL_PAD_DISP0_DAT18__IPU1_DISP0_DATA18 0x100f1
				MX6QDL_PAD_DISP0_DAT19__IPU1_DISP0_DATA19 0x100f1
				MX6QDL_PAD_DISP0_DAT20__IPU1_DISP0_DATA20 0x100f1
				MX6QDL_PAD_DISP0_DAT21__IPU1_DISP0_DATA21 0x100f1
				MX6QDL_PAD_DISP0_DAT22__IPU1_DISP0_DATA22 0x100f1
				MX6QDL_PAD_DISP0_DAT23__IPU1_DISP0_DATA23 0x100f1
				MX6QDL_PAD_DI0_DISP_CLK__IPU1_DI0_DISP_CLK 0x100f1
				MX6QDL_PAD_DI0_PIN15__IPU1_DI0_PIN15 0x100f1 /* DE */
				MX6QDL_PAD_DI0_PIN2__IPU1_DI0_PIN02 0x100f1  /* HSYNC */
				MX6QDL_PAD_DI0_PIN3__IPU1_DI0_PIN03 0x100f1  /* VSYNC */
			>;
		};
	};

	backlight {
		pinctrl_smx6_backlight: backlightgrp-smx6 {
			fsl,pins = <
				MX6QDL_PAD_SD1_DAT0__GPIO1_IO16 0x80000000
			>;
		};
	};

	lcdpower {
		pinctrl_smx6_lcdpower: lcdpowergrp-smx6 {
			fsl,pins = <
				MX6QDL_PAD_SD1_DAT1__GPIO1_IO17 0x80000000
			>;
		};
	};

	pwm4 {
		pinctrl_smx6_pwm4: pwm4grp-smx6 {
			fsl,pins = <
				MX6QDL_PAD_SD1_CMD__PWM4_OUT 0x80000000
			>;
		};
	};

	i2c1 {
		pinctrl_smx6_i2c1: i2c1grp-smx6 {
			fsl,pins = <
				MX6QDL_PAD_CSI0_DAT8__I2C1_SDA 0x4001b8b1
				MX6QDL_PAD_CSI0_DAT9__I2C1_SCL 0x4001b8b1
			>;
		};
	};

#ifndef SMX6_HDCP
	i2c2 {
		pinctrl_smx6_i2c2: i2c2grp-smx6 {
			fsl,pins = <
				MX6QDL_PAD_KEY_COL3__I2C2_SCL 0x4001b8b1
				MX6QDL_PAD_KEY_ROW3__I2C2_SDA 0x4001b8b1
			>;
		};
	};
#endif

#ifndef SMX6_PTP
	i2c3 {
		pinctrl_smx6_i2c3: i2c3grp-smx6 {
			fsl,pins = <
				MX6QDL_PAD_GPIO_5__I2C3_SCL  0x4001b8b1
				MX6QDL_PAD_GPIO_16__I2C3_SDA 0x4001b8b1
			>;
		};
	};
#endif

	i2c-gpio-0 {
		pinctrl_smx6_i2c_gpio_0: i2c-gpio-0grp-smx6 {
			fsl,pins = <
				/* SCL GPIO */
				MX6QDL_PAD_ENET_TXD0__GPIO1_IO30  0x80000000
				/* SDA GPIO */
				MX6QDL_PAD_ENET_TX_EN__GPIO1_IO28 0x80000000
			>;
		};
	};

	i2c-gpio-1 {
		pinctrl_smx6_i2c_gpio_1: i2c-gpio-1grp-smx6 {
			fsl,pins = <
				/* SCL GPIO */
				MX6QDL_PAD_GPIO_6__GPIO1_IO06   0x80000000
				/* SDA GPIO */
				MX6QDL_PAD_KEY_COL2__GPIO4_IO10 0x80000000
			>;
		};
	};

	i2c-gpio-2 {
		pinctrl_smx6_i2c_gpio_2: i2c-gpio-2grp-smx6 {
			fsl,pins = <
				/* SCL GPIO */
				MX6QDL_PAD_SD1_DAT2__GPIO1_IO19 0x80000000
				/* SDA GPIO */
				MX6QDL_PAD_SD1_DAT3__GPIO1_IO21 0x80000000
			>;
		};
	};

	pcie {
		pinctrl_smx6_pcie: pciegrp-smx6 {
			fsl,pins = <
				/* RST_PCIE_A# */
				MX6QDL_PAD_EIM_DA13__GPIO3_IO13 0x80000000
				/* PCIE_WAKE# */
				MX6QDL_PAD_SD3_DAT6__GPIO6_IO18 0x80000000
			>;
		};
	};

	flexcan1 {
		pinctrl_smx6_flexcan1: flexcan1grp-smx6 {
			fsl,pins = <
				MX6QDL_PAD_GPIO_7__FLEXCAN1_TX 0x80000000
				MX6QDL_PAD_GPIO_8__FLEXCAN1_RX 0x80000000
			>;
		};
	};

	flexcan2 {
		pinctrl_smx6_flexcan2: flexcan2grp-smx6 {
			fsl,pins = <
				MX6QDL_PAD_KEY_COL4__FLEXCAN2_TX 0x80000000
				MX6QDL_PAD_KEY_ROW4__FLEXCAN2_RX 0x80000000
			>;
		};
	};

	keys {
		pinctrl_smx6_keys: keysgrp-smx6 {
			fsl,pins = <
				/* Power Button */
				MX6QDL_PAD_NANDF_CS3__GPIO6_IO16 0x80000000
				/* SLEEP# */
				MX6QDL_PAD_SD3_DAT7__GPIO6_IO17 0x80000000
				/* LID# */
				MX6QDL_PAD_EIM_WAIT__GPIO5_IO00 0x80000000
			>;
		};
	};

	hdmi_cec {
		pinctrl_smx6_hdmi_cec: hdmi_cecgrp-smx6 {
			fsl,pins = <
				MX6QDL_PAD_EIM_A25__HDMI_TX_CEC_LINE 0x1f8b0
			>;
		};
	};

	hdmi_video {
		pinctrl_smx6_hdmi_video: hdmi_videogrp-smx6 {
			fsl,pins = <
				MX6QDL_PAD_KEY_COL3__HDMI_TX_DDC_SCL 0x4001b8b1
				MX6QDL_PAD_KEY_ROW3__HDMI_TX_DDC_SDA 0x4001b8b1
			>;
		};
	};

	wdog1 {
		pinctrl_smx6_wdog1: wdoggrp-smx6 {
			fsl,pins = <
				MX6QDL_PAD_GPIO_9__WDOG1_B 0x80000000
			>;
		};
	};

	audmux {
		pinctrl_smx6_audmux: audmuxgrp-smx6 {
			fsl,pins = <
				/* Port 3 is not shared with anything */
				MX6QDL_PAD_CSI0_DAT4__AUD3_TXC 0x80000000
				MX6QDL_PAD_CSI0_DAT5__AUD3_TXD 0x80000000
				MX6QDL_PAD_CSI0_DAT6__AUD3_TXFS 0x80000000
				MX6QDL_PAD_CSI0_DAT7__AUD3_RXD 0x80000000

				/* TODO: add conditional pinmux for ports
					 4 and 5 */
			>;
		};
	};
};

&snvs_poweroff {
	status = "okay";
};

